{"version":3,"sources":["../src/talk_to_figma_mcp/server.ts"],"sourcesContent":["#!/usr/bin/env node\r\n\r\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\r\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\r\nimport { z } from \"zod\";\r\nimport WebSocket from \"ws\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\n// Define TypeScript interfaces for Figma responses\r\ninterface FigmaResponse {\r\n  id: string;\r\n  result?: any;\r\n  error?: string;\r\n}\r\n\r\n// Define interface for command progress updates\r\ninterface CommandProgressUpdate {\r\n  type: 'command_progress';\r\n  commandId: string;\r\n  commandType: string;\r\n  status: 'started' | 'in_progress' | 'completed' | 'error';\r\n  progress: number;\r\n  totalItems: number;\r\n  processedItems: number;\r\n  currentChunk?: number;\r\n  totalChunks?: number;\r\n  chunkSize?: number;\r\n  message: string;\r\n  payload?: any;\r\n  timestamp: number;\r\n}\r\n\r\n// Add TypeScript interfaces for component overrides after line 21\r\ninterface ComponentOverride {\r\n  id: string;\r\n  overriddenFields: string[];\r\n}\r\n\r\n// Update the getInstanceOverridesResult interface to match the plugin implementation\r\ninterface getInstanceOverridesResult {\r\n  success: boolean;\r\n  message: string;\r\n  sourceInstanceId: string;\r\n  mainComponentId: string;\r\n  overridesCount: number;\r\n}\r\n\r\ninterface setInstanceOverridesResult {\r\n  success: boolean;\r\n  message: string;\r\n  totalCount?: number;\r\n  results?: Array<{\r\n    success: boolean;\r\n    instanceId: string;\r\n    instanceName: string;\r\n    appliedCount?: number;\r\n    message?: string;\r\n  }>;\r\n}\r\n\r\n// Custom logging functions that write to stderr instead of stdout to avoid being captured\r\nconst logger = {\r\n  info: (message: string) => process.stderr.write(`[INFO] ${message}\\n`),\r\n  debug: (message: string) => process.stderr.write(`[DEBUG] ${message}\\n`),\r\n  warn: (message: string) => process.stderr.write(`[WARN] ${message}\\n`),\r\n  error: (message: string) => process.stderr.write(`[ERROR] ${message}\\n`),\r\n  log: (message: string) => process.stderr.write(`[LOG] ${message}\\n`)\r\n};\r\n\r\n// WebSocket connection and request tracking\r\nlet ws: WebSocket | null = null;\r\nconst pendingRequests = new Map<string, {\r\n  resolve: (value: unknown) => void;\r\n  reject: (reason: unknown) => void;\r\n  timeout: ReturnType<typeof setTimeout>;\r\n  lastActivity: number; // Add timestamp for last activity\r\n}>();\r\n\r\n// Track which channel each client is in\r\nlet currentChannel: string | null = null;\r\n\r\n// Create MCP server\r\nconst server = new McpServer({\r\n  name: \"TalkToFigmaMCP\",\r\n  version: \"1.0.0\",\r\n});\r\n\r\n// Add command line argument parsing\r\nconst args = process.argv.slice(2);\r\nconst serverArg = args.find(arg => arg.startsWith('--server='));\r\nconst serverUrl = serverArg ? serverArg.split('=')[1] : 'localhost';\r\nconst WS_URL = serverUrl === 'localhost' ? `ws://${serverUrl}` : `wss://${serverUrl}`;\r\n\r\n// Document Info Tool\r\nserver.tool(\r\n  \"get_document_info\",\r\n  \"Get detailed information about the current Figma document\",\r\n  {},\r\n  async () => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_document_info\");\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting document info: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Selection Tool\r\nserver.tool(\r\n  \"get_selection\",\r\n  \"Get information about the current selection in Figma\",\r\n  {},\r\n  async () => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_selection\");\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting selection: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Read My Design Tool\r\nserver.tool(\r\n  \"read_my_design\",\r\n  \"Get detailed information about the current selection in Figma, including all node details\",\r\n  {},\r\n  async () => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"read_my_design\", {});\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting node info: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Node Info Tool\r\nserver.tool(\r\n  \"get_node_info\",\r\n  \"Get detailed information about a specific node in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to get information about\"),\r\n  },\r\n  async ({ nodeId }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_node_info\", { nodeId });\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(filterFigmaNode(result))\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting node info: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\nfunction rgbaToHex(color: any): string {\r\n  // skip if color is already hex\r\n  if (color.startsWith('#')) {\r\n    return color;\r\n  }\r\n\r\n  const r = Math.round(color.r * 255);\r\n  const g = Math.round(color.g * 255);\r\n  const b = Math.round(color.b * 255);\r\n  const a = Math.round(color.a * 255);\r\n\r\n  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}${a === 255 ? '' : a.toString(16).padStart(2, '0')}`;\r\n}\r\n\r\nfunction filterFigmaNode(node: any) {\r\n  // Skip VECTOR type nodes\r\n  if (node.type === \"VECTOR\") {\r\n    return null;\r\n  }\r\n\r\n  const filtered: any = {\r\n    id: node.id,\r\n    name: node.name,\r\n    type: node.type,\r\n  };\r\n\r\n  if (node.fills && node.fills.length > 0) {\r\n    filtered.fills = node.fills.map((fill: any) => {\r\n      const processedFill = { ...fill };\r\n\r\n      // Remove boundVariables and imageRef\r\n      delete processedFill.boundVariables;\r\n      delete processedFill.imageRef;\r\n\r\n      // Process gradientStops if present\r\n      if (processedFill.gradientStops) {\r\n        processedFill.gradientStops = processedFill.gradientStops.map((stop: any) => {\r\n          const processedStop = { ...stop };\r\n          // Convert color to hex if present\r\n          if (processedStop.color) {\r\n            processedStop.color = rgbaToHex(processedStop.color);\r\n          }\r\n          // Remove boundVariables\r\n          delete processedStop.boundVariables;\r\n          return processedStop;\r\n        });\r\n      }\r\n\r\n      // Convert solid fill colors to hex\r\n      if (processedFill.color) {\r\n        processedFill.color = rgbaToHex(processedFill.color);\r\n      }\r\n\r\n      return processedFill;\r\n    });\r\n  }\r\n\r\n  if (node.strokes && node.strokes.length > 0) {\r\n    filtered.strokes = node.strokes.map((stroke: any) => {\r\n      const processedStroke = { ...stroke };\r\n      // Remove boundVariables\r\n      delete processedStroke.boundVariables;\r\n      // Convert color to hex if present\r\n      if (processedStroke.color) {\r\n        processedStroke.color = rgbaToHex(processedStroke.color);\r\n      }\r\n      return processedStroke;\r\n    });\r\n  }\r\n\r\n  if (node.cornerRadius !== undefined) {\r\n    filtered.cornerRadius = node.cornerRadius;\r\n  }\r\n\r\n  if (node.absoluteBoundingBox) {\r\n    filtered.absoluteBoundingBox = node.absoluteBoundingBox;\r\n  }\r\n\r\n  if (node.characters) {\r\n    filtered.characters = node.characters;\r\n  }\r\n\r\n  if (node.style) {\r\n    filtered.style = {\r\n      fontFamily: node.style.fontFamily,\r\n      fontStyle: node.style.fontStyle,\r\n      fontWeight: node.style.fontWeight,\r\n      fontSize: node.style.fontSize,\r\n      textAlignHorizontal: node.style.textAlignHorizontal,\r\n      letterSpacing: node.style.letterSpacing,\r\n      lineHeightPx: node.style.lineHeightPx\r\n    };\r\n  }\r\n\r\n  if (node.children) {\r\n    filtered.children = node.children\r\n      .map((child: any) => filterFigmaNode(child))\r\n      .filter((child: any) => child !== null); // Remove null children (VECTOR nodes)\r\n  }\r\n\r\n  return filtered;\r\n}\r\n\r\n// Nodes Info Tool\r\nserver.tool(\r\n  \"get_nodes_info\",\r\n  \"Get detailed information about multiple nodes in Figma\",\r\n  {\r\n    nodeIds: z.array(z.string()).describe(\"Array of node IDs to get information about\")\r\n  },\r\n  async ({ nodeIds }) => {\r\n    try {\r\n      const results = await Promise.all(\r\n        nodeIds.map(async (nodeId) => {\r\n          const result = await sendCommandToFigma('get_node_info', { nodeId });\r\n          return { nodeId, info: result };\r\n        })\r\n      );\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(results.map((result) => filterFigmaNode(result.info)))\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting nodes info: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n\r\n// Create Rectangle Tool\r\nserver.tool(\r\n  \"create_rectangle\",\r\n  \"Create a new rectangle in Figma\",\r\n  {\r\n    x: z.number().describe(\"X position\"),\r\n    y: z.number().describe(\"Y position\"),\r\n    width: z.number().describe(\"Width of the rectangle\"),\r\n    height: z.number().describe(\"Height of the rectangle\"),\r\n    name: z.string().optional().describe(\"Optional name for the rectangle\"),\r\n    parentId: z\r\n      .string()\r\n      .optional()\r\n      .describe(\"Optional parent node ID to append the rectangle to\"),\r\n  },\r\n  async ({ x, y, width, height, name, parentId }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"create_rectangle\", {\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        name: name || \"Rectangle\",\r\n        parentId,\r\n      });\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Created rectangle \"${JSON.stringify(result)}\"`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error creating rectangle: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Create Frame Tool\r\nserver.tool(\r\n  \"create_frame\",\r\n  \"Create a new frame in Figma\",\r\n  {\r\n    x: z.number().describe(\"X position\"),\r\n    y: z.number().describe(\"Y position\"),\r\n    width: z.number().describe(\"Width of the frame\"),\r\n    height: z.number().describe(\"Height of the frame\"),\r\n    name: z.string().optional().describe(\"Optional name for the frame\"),\r\n    parentId: z\r\n      .string()\r\n      .optional()\r\n      .describe(\"Optional parent node ID to append the frame to\"),\r\n    fillColor: z\r\n      .object({\r\n        r: z.number().min(0).max(1).describe(\"Red component (0-1)\"),\r\n        g: z.number().min(0).max(1).describe(\"Green component (0-1)\"),\r\n        b: z.number().min(0).max(1).describe(\"Blue component (0-1)\"),\r\n        a: z\r\n          .number()\r\n          .min(0)\r\n          .max(1)\r\n          .optional()\r\n          .describe(\"Alpha component (0-1)\"),\r\n      })\r\n      .optional()\r\n      .describe(\"Fill color in RGBA format\"),\r\n    strokeColor: z\r\n      .object({\r\n        r: z.number().min(0).max(1).describe(\"Red component (0-1)\"),\r\n        g: z.number().min(0).max(1).describe(\"Green component (0-1)\"),\r\n        b: z.number().min(0).max(1).describe(\"Blue component (0-1)\"),\r\n        a: z\r\n          .number()\r\n          .min(0)\r\n          .max(1)\r\n          .optional()\r\n          .describe(\"Alpha component (0-1)\"),\r\n      })\r\n      .optional()\r\n      .describe(\"Stroke color in RGBA format\"),\r\n    strokeWeight: z.number().positive().optional().describe(\"Stroke weight\"),\r\n    layoutMode: z.enum([\"NONE\", \"HORIZONTAL\", \"VERTICAL\"]).optional().describe(\"Auto-layout mode for the frame\"),\r\n    layoutWrap: z.enum([\"NO_WRAP\", \"WRAP\"]).optional().describe(\"Whether the auto-layout frame wraps its children\"),\r\n    paddingTop: z.number().optional().describe(\"Top padding for auto-layout frame\"),\r\n    paddingRight: z.number().optional().describe(\"Right padding for auto-layout frame\"),\r\n    paddingBottom: z.number().optional().describe(\"Bottom padding for auto-layout frame\"),\r\n    paddingLeft: z.number().optional().describe(\"Left padding for auto-layout frame\"),\r\n    primaryAxisAlignItems: z\r\n      .enum([\"MIN\", \"MAX\", \"CENTER\", \"SPACE_BETWEEN\"])\r\n      .optional()\r\n      .describe(\"Primary axis alignment for auto-layout frame. Note: When set to SPACE_BETWEEN, itemSpacing will be ignored as children will be evenly spaced.\"),\r\n    counterAxisAlignItems: z.enum([\"MIN\", \"MAX\", \"CENTER\", \"BASELINE\"]).optional().describe(\"Counter axis alignment for auto-layout frame\"),\r\n    layoutSizingHorizontal: z.enum([\"FIXED\", \"HUG\", \"FILL\"]).optional().describe(\"Horizontal sizing mode for auto-layout frame\"),\r\n    layoutSizingVertical: z.enum([\"FIXED\", \"HUG\", \"FILL\"]).optional().describe(\"Vertical sizing mode for auto-layout frame\"),\r\n    itemSpacing: z\r\n      .number()\r\n      .optional()\r\n      .describe(\"Distance between children in auto-layout frame. Note: This value will be ignored if primaryAxisAlignItems is set to SPACE_BETWEEN.\")\r\n  },\r\n  async ({\r\n    x,\r\n    y,\r\n    width,\r\n    height,\r\n    name,\r\n    parentId,\r\n    fillColor,\r\n    strokeColor,\r\n    strokeWeight,\r\n    layoutMode,\r\n    layoutWrap,\r\n    paddingTop,\r\n    paddingRight,\r\n    paddingBottom,\r\n    paddingLeft,\r\n    primaryAxisAlignItems,\r\n    counterAxisAlignItems,\r\n    layoutSizingHorizontal,\r\n    layoutSizingVertical,\r\n    itemSpacing\r\n  }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"create_frame\", {\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        name: name || \"Frame\",\r\n        parentId,\r\n        fillColor: fillColor || { r: 1, g: 1, b: 1, a: 1 },\r\n        strokeColor: strokeColor,\r\n        strokeWeight: strokeWeight,\r\n        layoutMode,\r\n        layoutWrap,\r\n        paddingTop,\r\n        paddingRight,\r\n        paddingBottom,\r\n        paddingLeft,\r\n        primaryAxisAlignItems,\r\n        counterAxisAlignItems,\r\n        layoutSizingHorizontal,\r\n        layoutSizingVertical,\r\n        itemSpacing\r\n      });\r\n      const typedResult = result as { name: string; id: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Created frame \"${typedResult.name}\" with ID: ${typedResult.id}. Use the ID as the parentId to appendChild inside this frame.`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error creating frame: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Create Text Tool\r\nserver.tool(\r\n  \"create_text\",\r\n  \"Create a new text element in Figma\",\r\n  {\r\n    x: z.number().describe(\"X position\"),\r\n    y: z.number().describe(\"Y position\"),\r\n    text: z.string().describe(\"Text content\"),\r\n    fontSize: z.number().optional().describe(\"Font size (default: 14)\"),\r\n    fontWeight: z\r\n      .number()\r\n      .optional()\r\n      .describe(\"Font weight (e.g., 400 for Regular, 700 for Bold)\"),\r\n    fontColor: z\r\n      .object({\r\n        r: z.number().min(0).max(1).describe(\"Red component (0-1)\"),\r\n        g: z.number().min(0).max(1).describe(\"Green component (0-1)\"),\r\n        b: z.number().min(0).max(1).describe(\"Blue component (0-1)\"),\r\n        a: z\r\n          .number()\r\n          .min(0)\r\n          .max(1)\r\n          .optional()\r\n          .describe(\"Alpha component (0-1)\"),\r\n      })\r\n      .optional()\r\n      .describe(\"Font color in RGBA format\"),\r\n    name: z\r\n      .string()\r\n      .optional()\r\n      .describe(\"Semantic layer name for the text node\"),\r\n    parentId: z\r\n      .string()\r\n      .optional()\r\n      .describe(\"Optional parent node ID to append the text to\"),\r\n  },\r\n  async ({ x, y, text, fontSize, fontWeight, fontColor, name, parentId }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"create_text\", {\r\n        x,\r\n        y,\r\n        text,\r\n        fontSize: fontSize || 14,\r\n        fontWeight: fontWeight || 400,\r\n        fontColor: fontColor || { r: 0, g: 0, b: 0, a: 1 },\r\n        name: name || \"Text\",\r\n        parentId,\r\n      });\r\n      const typedResult = result as { name: string; id: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Created text \"${typedResult.name}\" with ID: ${typedResult.id}`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error creating text: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Fill Color Tool\r\nserver.tool(\r\n  \"set_fill_color\",\r\n  \"Set the fill color of a node in Figma can be TextNode or FrameNode\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to modify\"),\r\n    r: z.number().min(0).max(1).describe(\"Red component (0-1)\"),\r\n    g: z.number().min(0).max(1).describe(\"Green component (0-1)\"),\r\n    b: z.number().min(0).max(1).describe(\"Blue component (0-1)\"),\r\n    a: z.number().min(0).max(1).optional().describe(\"Alpha component (0-1)\"),\r\n  },\r\n  async ({ nodeId, r, g, b, a }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_fill_color\", {\r\n        nodeId,\r\n        color: { r, g, b, a: a || 1 },\r\n      });\r\n      const typedResult = result as { name: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set fill color of node \"${typedResult.name\r\n              }\" to RGBA(${r}, ${g}, ${b}, ${a || 1})`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting fill color: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Stroke Color Tool\r\nserver.tool(\r\n  \"set_stroke_color\",\r\n  \"Set the stroke color of a node in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to modify\"),\r\n    r: z.number().min(0).max(1).describe(\"Red component (0-1)\"),\r\n    g: z.number().min(0).max(1).describe(\"Green component (0-1)\"),\r\n    b: z.number().min(0).max(1).describe(\"Blue component (0-1)\"),\r\n    a: z.number().min(0).max(1).optional().describe(\"Alpha component (0-1)\"),\r\n    weight: z.number().positive().optional().describe(\"Stroke weight\"),\r\n  },\r\n  async ({ nodeId, r, g, b, a, weight }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_stroke_color\", {\r\n        nodeId,\r\n        color: { r, g, b, a: a || 1 },\r\n        weight: weight || 1,\r\n      });\r\n      const typedResult = result as { name: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set stroke color of node \"${typedResult.name\r\n              }\" to RGBA(${r}, ${g}, ${b}, ${a || 1}) with weight ${weight || 1}`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting stroke color: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Move Node Tool\r\nserver.tool(\r\n  \"move_node\",\r\n  \"Move a node to a new position in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to move\"),\r\n    x: z.number().describe(\"New X position\"),\r\n    y: z.number().describe(\"New Y position\"),\r\n  },\r\n  async ({ nodeId, x, y }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"move_node\", { nodeId, x, y });\r\n      const typedResult = result as { name: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Moved node \"${typedResult.name}\" to position (${x}, ${y})`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error moving node: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Clone Node Tool\r\nserver.tool(\r\n  \"clone_node\",\r\n  \"Clone an existing node in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to clone\"),\r\n    x: z.number().optional().describe(\"New X position for the clone\"),\r\n    y: z.number().optional().describe(\"New Y position for the clone\")\r\n  },\r\n  async ({ nodeId, x, y }) => {\r\n    try {\r\n      const result = await sendCommandToFigma('clone_node', { nodeId, x, y });\r\n      const typedResult = result as { name: string, id: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Cloned node \"${typedResult.name}\" with new ID: ${typedResult.id}${x !== undefined && y !== undefined ? ` at position (${x}, ${y})` : ''}`\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error cloning node: ${error instanceof Error ? error.message : String(error)}`\r\n          }\r\n        ]\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Resize Node Tool\r\nserver.tool(\r\n  \"resize_node\",\r\n  \"Resize a node in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to resize\"),\r\n    width: z.number().positive().describe(\"New width\"),\r\n    height: z.number().positive().describe(\"New height\"),\r\n  },\r\n  async ({ nodeId, width, height }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"resize_node\", {\r\n        nodeId,\r\n        width,\r\n        height,\r\n      });\r\n      const typedResult = result as { name: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Resized node \"${typedResult.name}\" to width ${width} and height ${height}`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error resizing node: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Delete Node Tool\r\nserver.tool(\r\n  \"delete_node\",\r\n  \"Delete a node from Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to delete\"),\r\n  },\r\n  async ({ nodeId }) => {\r\n    try {\r\n      await sendCommandToFigma(\"delete_node\", { nodeId });\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Deleted node with ID: ${nodeId}`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error deleting node: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Delete Multiple Nodes Tool\r\nserver.tool(\r\n  \"delete_multiple_nodes\",\r\n  \"Delete multiple nodes from Figma at once\",\r\n  {\r\n    nodeIds: z.array(z.string()).describe(\"Array of node IDs to delete\"),\r\n  },\r\n  async ({ nodeIds }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"delete_multiple_nodes\", { nodeIds });\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error deleting multiple nodes: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Export Node as Image Tool\r\nserver.tool(\r\n  \"export_node_as_image\",\r\n  \"Export a node as an image from Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to export\"),\r\n    format: z\r\n      .enum([\"PNG\", \"JPG\", \"SVG\", \"PDF\"])\r\n      .optional()\r\n      .describe(\"Export format\"),\r\n    scale: z.number().positive().optional().describe(\"Export scale\"),\r\n  },\r\n  async ({ nodeId, format, scale }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"export_node_as_image\", {\r\n        nodeId,\r\n        format: format || \"PNG\",\r\n        scale: scale || 1,\r\n      });\r\n      const typedResult = result as { imageData: string; mimeType: string };\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"image\",\r\n            data: typedResult.imageData,\r\n            mimeType: typedResult.mimeType || \"image/png\",\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error exporting node as image: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Text Content Tool\r\nserver.tool(\r\n  \"set_text_content\",\r\n  \"Set the text content of an existing text node in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the text node to modify\"),\r\n    text: z.string().describe(\"New text content\"),\r\n  },\r\n  async ({ nodeId, text }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_text_content\", {\r\n        nodeId,\r\n        text,\r\n      });\r\n      const typedResult = result as { name: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Updated text content of node \"${typedResult.name}\" to \"${text}\"`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting text content: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Get Styles Tool\r\nserver.tool(\r\n  \"get_styles\",\r\n  \"Get all styles from the current Figma document\",\r\n  {},\r\n  async () => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_styles\");\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting styles: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Get Local Components Tool\r\nserver.tool(\r\n  \"get_local_components\",\r\n  \"Get all local components from the Figma document\",\r\n  {},\r\n  async () => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_local_components\");\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting local components: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Get Annotations Tool\r\nserver.tool(\r\n  \"get_annotations\",\r\n  \"Get all annotations in the current document or specific node\",\r\n  {\r\n    nodeId: z.string().optional().describe(\"Optional node ID to get annotations for specific node\"),\r\n    includeCategories: z.boolean().optional().default(true).describe(\"Whether to include category information\")\r\n  },\r\n  async ({ nodeId, includeCategories }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_annotations\", {\r\n        nodeId,\r\n        includeCategories\r\n      });\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting annotations: ${error instanceof Error ? error.message : String(error)}`\r\n          }\r\n        ]\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Annotation Tool\r\nserver.tool(\r\n  \"set_annotation\",\r\n  \"Create or update an annotation\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to annotate\"),\r\n    annotationId: z.string().optional().describe(\"The ID of the annotation to update (if updating existing annotation)\"),\r\n    labelMarkdown: z.string().describe(\"The annotation text in markdown format\"),\r\n    categoryId: z.string().optional().describe(\"The ID of the annotation category\"),\r\n    properties: z.array(z.object({\r\n      type: z.string()\r\n    })).optional().describe(\"Additional properties for the annotation\")\r\n  },\r\n  async ({ nodeId, annotationId, labelMarkdown, categoryId, properties }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_annotation\", {\r\n        nodeId,\r\n        annotationId,\r\n        labelMarkdown,\r\n        categoryId,\r\n        properties\r\n      });\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting annotation: ${error instanceof Error ? error.message : String(error)}`\r\n          }\r\n        ]\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\ninterface SetMultipleAnnotationsParams {\r\n  nodeId: string;\r\n  annotations: Array<{\r\n    nodeId: string;\r\n    labelMarkdown: string;\r\n    categoryId?: string;\r\n    annotationId?: string;\r\n    properties?: Array<{ type: string }>;\r\n  }>;\r\n}\r\n\r\n// Set Multiple Annotations Tool\r\nserver.tool(\r\n  \"set_multiple_annotations\",\r\n  \"Set multiple annotations parallelly in a node\",\r\n  {\r\n    nodeId: z\r\n      .string()\r\n      .describe(\"The ID of the node containing the elements to annotate\"),\r\n    annotations: z\r\n      .array(\r\n        z.object({\r\n          nodeId: z.string().describe(\"The ID of the node to annotate\"),\r\n          labelMarkdown: z.string().describe(\"The annotation text in markdown format\"),\r\n          categoryId: z.string().optional().describe(\"The ID of the annotation category\"),\r\n          annotationId: z.string().optional().describe(\"The ID of the annotation to update (if updating existing annotation)\"),\r\n          properties: z.array(z.object({\r\n            type: z.string()\r\n          })).optional().describe(\"Additional properties for the annotation\")\r\n        })\r\n      )\r\n      .describe(\"Array of annotations to apply\"),\r\n  },\r\n  async ({ nodeId, annotations }, extra) => {\r\n    try {\r\n      if (!annotations || annotations.length === 0) {\r\n        return {\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text: \"No annotations provided\",\r\n            },\r\n          ],\r\n        };\r\n      }\r\n\r\n      // Initial response to indicate we're starting the process\r\n      const initialStatus = {\r\n        type: \"text\" as const,\r\n        text: `Starting annotation process for ${annotations.length} nodes. This will be processed in batches of 5...`,\r\n      };\r\n\r\n      // Track overall progress\r\n      let totalProcessed = 0;\r\n      const totalToProcess = annotations.length;\r\n\r\n      // Use the plugin's set_multiple_annotations function with chunking\r\n      const result = await sendCommandToFigma(\"set_multiple_annotations\", {\r\n        nodeId,\r\n        annotations,\r\n      });\r\n\r\n      // Cast the result to a specific type to work with it safely\r\n      interface AnnotationResult {\r\n        success: boolean;\r\n        nodeId: string;\r\n        annotationsApplied?: number;\r\n        annotationsFailed?: number;\r\n        totalAnnotations?: number;\r\n        completedInChunks?: number;\r\n        results?: Array<{\r\n          success: boolean;\r\n          nodeId: string;\r\n          error?: string;\r\n          annotationId?: string;\r\n        }>;\r\n      }\r\n\r\n      const typedResult = result as AnnotationResult;\r\n\r\n      // Format the results for display\r\n      const success = typedResult.annotationsApplied && typedResult.annotationsApplied > 0;\r\n      const progressText = `\r\n      Annotation process completed:\r\n      - ${typedResult.annotationsApplied || 0} of ${totalToProcess} successfully applied\r\n      - ${typedResult.annotationsFailed || 0} failed\r\n      - Processed in ${typedResult.completedInChunks || 1} batches\r\n      `;\r\n\r\n      // Detailed results\r\n      const detailedResults = typedResult.results || [];\r\n      const failedResults = detailedResults.filter(item => !item.success);\r\n\r\n      // Create the detailed part of the response\r\n      let detailedResponse = \"\";\r\n      if (failedResults.length > 0) {\r\n        detailedResponse = `\\n\\nNodes that failed:\\n${failedResults.map(item =>\r\n          `- ${item.nodeId}: ${item.error || \"Unknown error\"}`\r\n        ).join('\\n')}`;\r\n      }\r\n\r\n      return {\r\n        content: [\r\n          initialStatus,\r\n          {\r\n            type: \"text\" as const,\r\n            text: progressText + detailedResponse,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting multiple annotations: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Create Component Instance Tool\r\nserver.tool(\r\n  \"create_component_instance\",\r\n  \"Create an instance of a component in Figma\",\r\n  {\r\n    componentKey: z.string().describe(\"Key of the component to instantiate\"),\r\n    x: z.number().describe(\"X position\"),\r\n    y: z.number().describe(\"Y position\"),\r\n    parentId: z.string().describe(\"parentId\"),\r\n  },\r\n  async ({ componentKey, x, y, parentId }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"create_component_instance\", {\r\n        componentKey,\r\n        x,\r\n        y,\r\n        parentId\r\n      });\r\n      const typedResult = result as any;\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(typedResult),\r\n          }\r\n        ]\r\n      }\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error creating component instance: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Copy Instance Overrides Tool\r\nserver.tool(\r\n  \"get_instance_overrides\",\r\n  \"Get all override properties from a selected component instance. These overrides can be applied to other instances, which will swap them to match the source component.\",\r\n  {\r\n    nodeId: z.string().optional().describe(\"Optional ID of the component instance to get overrides from. If not provided, currently selected instance will be used.\"),\r\n  },\r\n  async ({ nodeId }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_instance_overrides\", { \r\n        instanceNodeId: nodeId || null \r\n      });\r\n      const typedResult = result as getInstanceOverridesResult;\r\n      \r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: typedResult.success \r\n              ? `Successfully got instance overrides: ${typedResult.message}`\r\n              : `Failed to get instance overrides: ${typedResult.message}`\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error copying instance overrides: ${error instanceof Error ? error.message : String(error)}`\r\n          }\r\n        ]\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Instance Overrides Tool\r\nserver.tool(\r\n  \"set_instance_overrides\",\r\n  \"Apply previously copied overrides to selected component instances. Target instances will be swapped to the source component and all copied override properties will be applied.\",\r\n  {\r\n    sourceInstanceId: z.string().describe(\"ID of the source component instance\"),\r\n    targetNodeIds: z.array(z.string()).describe(\"Array of target instance IDs. Currently selected instances will be used.\")\r\n  },\r\n  async ({ sourceInstanceId, targetNodeIds }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_instance_overrides\", {\r\n        sourceInstanceId: sourceInstanceId,\r\n        targetNodeIds: targetNodeIds || []\r\n      });\r\n      const typedResult = result as setInstanceOverridesResult;\r\n      \r\n      if (typedResult.success) {\r\n        const successCount = typedResult.results?.filter(r => r.success).length || 0;\r\n        return {\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text: `Successfully applied ${typedResult.totalCount || 0} overrides to ${successCount} instances.`\r\n            }\r\n          ]\r\n        };\r\n      } else {\r\n        return {\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text: `Failed to set instance overrides: ${typedResult.message}`\r\n            }\r\n          ]\r\n        };\r\n      }\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting instance overrides: ${error instanceof Error ? error.message : String(error)}`\r\n          }\r\n        ]\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n\r\n// Set Corner Radius Tool\r\nserver.tool(\r\n  \"set_corner_radius\",\r\n  \"Set the corner radius of a node in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the node to modify\"),\r\n    radius: z.number().min(0).describe(\"Corner radius value\"),\r\n    corners: z\r\n      .array(z.boolean())\r\n      .length(4)\r\n      .optional()\r\n      .describe(\r\n        \"Optional array of 4 booleans to specify which corners to round [topLeft, topRight, bottomRight, bottomLeft]\"\r\n      ),\r\n  },\r\n  async ({ nodeId, radius, corners }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_corner_radius\", {\r\n        nodeId,\r\n        radius,\r\n        corners: corners || [true, true, true, true],\r\n      });\r\n      const typedResult = result as { name: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set corner radius of node \"${typedResult.name}\" to ${radius}px`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting corner radius: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Define design strategy prompt\r\nserver.prompt(\r\n  \"design_strategy\",\r\n  \"Best practices for working with Figma designs\",\r\n  (extra) => {\r\n    return {\r\n      messages: [\r\n        {\r\n          role: \"assistant\",\r\n          content: {\r\n            type: \"text\",\r\n            text: `When working with Figma designs, follow these best practices:\r\n\r\n1. Start with Document Structure:\r\n   - First use get_document_info() to understand the current document\r\n   - Plan your layout hierarchy before creating elements\r\n   - Create a main container frame for each screen/section\r\n\r\n2. Naming Conventions:\r\n   - Use descriptive, semantic names for all elements\r\n   - Follow a consistent naming pattern (e.g., \"Login Screen\", \"Logo Container\", \"Email Input\")\r\n   - Group related elements with meaningful names\r\n\r\n3. Layout Hierarchy:\r\n   - Create parent frames first, then add child elements\r\n   - For forms/login screens:\r\n     * Start with the main screen container frame\r\n     * Create a logo container at the top\r\n     * Group input fields in their own containers\r\n     * Place action buttons (login, submit) after inputs\r\n     * Add secondary elements (forgot password, signup links) last\r\n\r\n4. Input Fields Structure:\r\n   - Create a container frame for each input field\r\n   - Include a label text above or inside the input\r\n   - Group related inputs (e.g., username/password) together\r\n\r\n5. Element Creation:\r\n   - Use create_frame() for containers and input fields\r\n   - Use create_text() for labels, buttons text, and links\r\n   - Set appropriate colors and styles:\r\n     * Use fillColor for backgrounds\r\n     * Use strokeColor for borders\r\n     * Set proper fontWeight for different text elements\r\n\r\n6. Mofifying existing elements:\r\n  - use set_text_content() to modify text content.\r\n\r\n7. Visual Hierarchy:\r\n   - Position elements in logical reading order (top to bottom)\r\n   - Maintain consistent spacing between elements\r\n   - Use appropriate font sizes for different text types:\r\n     * Larger for headings/welcome text\r\n     * Medium for input labels\r\n     * Standard for button text\r\n     * Smaller for helper text/links\r\n\r\n8. Best Practices:\r\n   - Verify each creation with get_node_info()\r\n   - Use parentId to maintain proper hierarchy\r\n   - Group related elements together in frames\r\n   - Keep consistent spacing and alignment\r\n\r\nExample Login Screen Structure:\r\n- Login Screen (main frame)\r\n  - Logo Container (frame)\r\n    - Logo (image/text)\r\n  - Welcome Text (text)\r\n  - Input Container (frame)\r\n    - Email Input (frame)\r\n      - Email Label (text)\r\n      - Email Field (frame)\r\n    - Password Input (frame)\r\n      - Password Label (text)\r\n      - Password Field (frame)\r\n  - Login Button (frame)\r\n    - Button Text (text)\r\n  - Helper Links (frame)\r\n    - Forgot Password (text)\r\n    - Don't have account (text)`,\r\n          },\r\n        },\r\n      ],\r\n      description: \"Best practices for working with Figma designs\",\r\n    };\r\n  }\r\n);\r\n\r\nserver.prompt(\r\n  \"read_design_strategy\",\r\n  \"Best practices for reading Figma designs\",\r\n  (extra) => {\r\n    return {\r\n      messages: [\r\n        {\r\n          role: \"assistant\",\r\n          content: {\r\n            type: \"text\",\r\n            text: `When reading Figma designs, follow these best practices:\r\n\r\n1. Start with selection:\r\n   - First use read_my_design() to understand the current selection\r\n   - If no selection ask user to select single or multiple nodes\r\n`,\r\n          },\r\n        },\r\n      ],\r\n      description: \"Best practices for reading Figma designs\",\r\n    };\r\n  }\r\n);\r\n\r\n// Text Node Scanning Tool\r\nserver.tool(\r\n  \"scan_text_nodes\",\r\n  \"Scan all text nodes in the selected Figma node\",\r\n  {\r\n    nodeId: z.string().describe(\"ID of the node to scan\"),\r\n  },\r\n  async ({ nodeId }) => {\r\n    try {\r\n      // Initial response to indicate we're starting the process\r\n      const initialStatus = {\r\n        type: \"text\" as const,\r\n        text: \"Starting text node scanning. This may take a moment for large designs...\",\r\n      };\r\n\r\n      // Use the plugin's scan_text_nodes function with chunking flag\r\n      const result = await sendCommandToFigma(\"scan_text_nodes\", {\r\n        nodeId,\r\n        useChunking: true,  // Enable chunking on the plugin side\r\n        chunkSize: 10       // Process 10 nodes at a time\r\n      });\r\n\r\n      // If the result indicates chunking was used, format the response accordingly\r\n      if (result && typeof result === 'object' && 'chunks' in result) {\r\n        const typedResult = result as {\r\n          success: boolean,\r\n          totalNodes: number,\r\n          processedNodes: number,\r\n          chunks: number,\r\n          textNodes: Array<any>\r\n        };\r\n\r\n        const summaryText = `\r\n        Scan completed:\r\n        - Found ${typedResult.totalNodes} text nodes\r\n        - Processed in ${typedResult.chunks} chunks\r\n        `;\r\n\r\n        return {\r\n          content: [\r\n            initialStatus,\r\n            {\r\n              type: \"text\" as const,\r\n              text: summaryText\r\n            },\r\n            {\r\n              type: \"text\" as const,\r\n              text: JSON.stringify(typedResult.textNodes, null, 2)\r\n            }\r\n          ],\r\n        };\r\n      }\r\n\r\n      // If chunking wasn't used or wasn't reported in the result format, return the result as is\r\n      return {\r\n        content: [\r\n          initialStatus,\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result, null, 2),\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error scanning text nodes: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Node Type Scanning Tool\r\nserver.tool(\r\n  \"scan_nodes_by_types\",\r\n  \"Scan for child nodes with specific types in the selected Figma node\",\r\n  {\r\n    nodeId: z.string().describe(\"ID of the node to scan\"),\r\n    types: z.array(z.string()).describe(\"Array of node types to find in the child nodes (e.g. ['COMPONENT', 'FRAME'])\")\r\n  },\r\n  async ({ nodeId, types }) => {\r\n    try {\r\n      // Initial response to indicate we're starting the process\r\n      const initialStatus = {\r\n        type: \"text\" as const,\r\n        text: `Starting node type scanning for types: ${types.join(', ')}...`,\r\n      };\r\n\r\n      // Use the plugin's scan_nodes_by_types function\r\n      const result = await sendCommandToFigma(\"scan_nodes_by_types\", {\r\n        nodeId,\r\n        types\r\n      });\r\n\r\n      // Format the response\r\n      if (result && typeof result === 'object' && 'matchingNodes' in result) {\r\n        const typedResult = result as {\r\n          success: boolean,\r\n          count: number,\r\n          matchingNodes: Array<{\r\n            id: string,\r\n            name: string,\r\n            type: string,\r\n            bbox: {\r\n              x: number,\r\n              y: number,\r\n              width: number,\r\n              height: number\r\n            }\r\n          }>,\r\n          searchedTypes: Array<string>\r\n        };\r\n\r\n        const summaryText = `Scan completed: Found ${typedResult.count} nodes matching types: ${typedResult.searchedTypes.join(', ')}`;\r\n\r\n        return {\r\n          content: [\r\n            initialStatus,\r\n            {\r\n              type: \"text\" as const,\r\n              text: summaryText\r\n            },\r\n            {\r\n              type: \"text\" as const,\r\n              text: JSON.stringify(typedResult.matchingNodes, null, 2)\r\n            }\r\n          ],\r\n        };\r\n      }\r\n\r\n      // If the result is in an unexpected format, return it as is\r\n      return {\r\n        content: [\r\n          initialStatus,\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result, null, 2),\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error scanning nodes by types: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Text Replacement Strategy Prompt\r\nserver.prompt(\r\n  \"text_replacement_strategy\",\r\n  \"Systematic approach for replacing text in Figma designs\",\r\n  (extra) => {\r\n    return {\r\n      messages: [\r\n        {\r\n          role: \"assistant\",\r\n          content: {\r\n            type: \"text\",\r\n            text: `# Intelligent Text Replacement Strategy\r\n\r\n## 1. Analyze Design & Identify Structure\r\n- Scan text nodes to understand the overall structure of the design\r\n- Use AI pattern recognition to identify logical groupings:\r\n  * Tables (rows, columns, headers, cells)\r\n  * Lists (items, headers, nested lists)\r\n  * Card groups (similar cards with recurring text fields)\r\n  * Forms (labels, input fields, validation text)\r\n  * Navigation (menu items, breadcrumbs)\r\n\\`\\`\\`\r\nscan_text_nodes(nodeId: \"node-id\")\r\nget_node_info(nodeId: \"node-id\")  // optional\r\n\\`\\`\\`\r\n\r\n## 2. Strategic Chunking for Complex Designs\r\n- Divide replacement tasks into logical content chunks based on design structure\r\n- Use one of these chunking strategies that best fits the design:\r\n  * **Structural Chunking**: Table rows/columns, list sections, card groups\r\n  * **Spatial Chunking**: Top-to-bottom, left-to-right in screen areas\r\n  * **Semantic Chunking**: Content related to the same topic or functionality\r\n  * **Component-Based Chunking**: Process similar component instances together\r\n\r\n## 3. Progressive Replacement with Verification\r\n- Create a safe copy of the node for text replacement\r\n- Replace text chunk by chunk with continuous progress updates\r\n- After each chunk is processed:\r\n  * Export that section as a small, manageable image\r\n  * Verify text fits properly and maintain design integrity\r\n  * Fix issues before proceeding to the next chunk\r\n\r\n\\`\\`\\`\r\n// Clone the node to create a safe copy\r\nclone_node(nodeId: \"selected-node-id\", x: [new-x], y: [new-y])\r\n\r\n// Replace text chunk by chunk\r\nset_multiple_text_contents(\r\n  nodeId: \"parent-node-id\", \r\n  text: [\r\n    { nodeId: \"node-id-1\", text: \"New text 1\" },\r\n    // More nodes in this chunk...\r\n  ]\r\n)\r\n\r\n// Verify chunk with small, targeted image exports\r\nexport_node_as_image(nodeId: \"chunk-node-id\", format: \"PNG\", scale: 0.5)\r\n\\`\\`\\`\r\n\r\n## 4. Intelligent Handling for Table Data\r\n- For tabular content:\r\n  * Process one row or column at a time\r\n  * Maintain alignment and spacing between cells\r\n  * Consider conditional formatting based on cell content\r\n  * Preserve header/data relationships\r\n\r\n## 5. Smart Text Adaptation\r\n- Adaptively handle text based on container constraints:\r\n  * Auto-detect space constraints and adjust text length\r\n  * Apply line breaks at appropriate linguistic points\r\n  * Maintain text hierarchy and emphasis\r\n  * Consider font scaling for critical content that must fit\r\n\r\n## 6. Progressive Feedback Loop\r\n- Establish a continuous feedback loop during replacement:\r\n  * Real-time progress updates (0-100%)\r\n  * Small image exports after each chunk for verification\r\n  * Issues identified early and resolved incrementally\r\n  * Quick adjustments applied to subsequent chunks\r\n\r\n## 7. Final Verification & Context-Aware QA\r\n- After all chunks are processed:\r\n  * Export the entire design at reduced scale for final verification\r\n  * Check for cross-chunk consistency issues\r\n  * Verify proper text flow between different sections\r\n  * Ensure design harmony across the full composition\r\n\r\n## 8. Chunk-Specific Export Scale Guidelines\r\n- Scale exports appropriately based on chunk size:\r\n  * Small chunks (1-5 elements): scale 1.0\r\n  * Medium chunks (6-20 elements): scale 0.7\r\n  * Large chunks (21-50 elements): scale 0.5\r\n  * Very large chunks (50+ elements): scale 0.3\r\n  * Full design verification: scale 0.2\r\n\r\n## Sample Chunking Strategy for Common Design Types\r\n\r\n### Tables\r\n- Process by logical rows (5-10 rows per chunk)\r\n- Alternative: Process by column for columnar analysis\r\n- Tip: Always include header row in first chunk for reference\r\n\r\n### Card Lists\r\n- Group 3-5 similar cards per chunk\r\n- Process entire cards to maintain internal consistency\r\n- Verify text-to-image ratio within cards after each chunk\r\n\r\n### Forms\r\n- Group related fields (e.g., \"Personal Information\", \"Payment Details\")\r\n- Process labels and input fields together\r\n- Ensure validation messages and hints are updated with their fields\r\n\r\n### Navigation & Menus\r\n- Process hierarchical levels together (main menu, submenu)\r\n- Respect information architecture relationships\r\n- Verify menu fit and alignment after replacement\r\n\r\n## Best Practices\r\n- **Preserve Design Intent**: Always prioritize design integrity\r\n- **Structural Consistency**: Maintain alignment, spacing, and hierarchy\r\n- **Visual Feedback**: Verify each chunk visually before proceeding\r\n- **Incremental Improvement**: Learn from each chunk to improve subsequent ones\r\n- **Balance Automation & Control**: Let AI handle repetitive replacements but maintain oversight\r\n- **Respect Content Relationships**: Keep related content consistent across chunks\r\n\r\nRemember that text is never just textit's a core design element that must work harmoniously with the overall composition. This chunk-based strategy allows you to methodically transform text while maintaining design integrity.`,\r\n          },\r\n        },\r\n      ],\r\n      description: \"Systematic approach for replacing text in Figma designs\",\r\n    };\r\n  }\r\n);\r\n\r\n// Set Multiple Text Contents Tool\r\nserver.tool(\r\n  \"set_multiple_text_contents\",\r\n  \"Set multiple text contents parallelly in a node\",\r\n  {\r\n    nodeId: z\r\n      .string()\r\n      .describe(\"The ID of the node containing the text nodes to replace\"),\r\n    text: z\r\n      .array(\r\n        z.object({\r\n          nodeId: z.string().describe(\"The ID of the text node\"),\r\n          text: z.string().describe(\"The replacement text\"),\r\n        })\r\n      )\r\n      .describe(\"Array of text node IDs and their replacement texts\"),\r\n  },\r\n  async ({ nodeId, text }, extra) => {\r\n    try {\r\n      if (!text || text.length === 0) {\r\n        return {\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text: \"No text provided\",\r\n            },\r\n          ],\r\n        };\r\n      }\r\n\r\n      // Initial response to indicate we're starting the process\r\n      const initialStatus = {\r\n        type: \"text\" as const,\r\n        text: `Starting text replacement for ${text.length} nodes. This will be processed in batches of 5...`,\r\n      };\r\n\r\n      // Track overall progress\r\n      let totalProcessed = 0;\r\n      const totalToProcess = text.length;\r\n\r\n      // Use the plugin's set_multiple_text_contents function with chunking\r\n      const result = await sendCommandToFigma(\"set_multiple_text_contents\", {\r\n        nodeId,\r\n        text,\r\n      });\r\n\r\n      // Cast the result to a specific type to work with it safely\r\n      interface TextReplaceResult {\r\n        success: boolean;\r\n        nodeId: string;\r\n        replacementsApplied?: number;\r\n        replacementsFailed?: number;\r\n        totalReplacements?: number;\r\n        completedInChunks?: number;\r\n        results?: Array<{\r\n          success: boolean;\r\n          nodeId: string;\r\n          error?: string;\r\n          originalText?: string;\r\n          translatedText?: string;\r\n        }>;\r\n      }\r\n\r\n      const typedResult = result as TextReplaceResult;\r\n\r\n      // Format the results for display\r\n      const success = typedResult.replacementsApplied && typedResult.replacementsApplied > 0;\r\n      const progressText = `\r\n      Text replacement completed:\r\n      - ${typedResult.replacementsApplied || 0} of ${totalToProcess} successfully updated\r\n      - ${typedResult.replacementsFailed || 0} failed\r\n      - Processed in ${typedResult.completedInChunks || 1} batches\r\n      `;\r\n\r\n      // Detailed results\r\n      const detailedResults = typedResult.results || [];\r\n      const failedResults = detailedResults.filter(item => !item.success);\r\n\r\n      // Create the detailed part of the response\r\n      let detailedResponse = \"\";\r\n      if (failedResults.length > 0) {\r\n        detailedResponse = `\\n\\nNodes that failed:\\n${failedResults.map(item =>\r\n          `- ${item.nodeId}: ${item.error || \"Unknown error\"}`\r\n        ).join('\\n')}`;\r\n      }\r\n\r\n      return {\r\n        content: [\r\n          initialStatus,\r\n          {\r\n            type: \"text\" as const,\r\n            text: progressText + detailedResponse,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting multiple text contents: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Annotation Conversion Strategy Prompt\r\nserver.prompt(\r\n  \"annotation_conversion_strategy\",\r\n  \"Strategy for converting manual annotations to Figma's native annotations\",\r\n  (extra) => {\r\n    return {\r\n      messages: [\r\n        {\r\n          role: \"assistant\",\r\n          content: {\r\n            type: \"text\",\r\n            text: `# Automatic Annotation Conversion\r\n            \r\n## Process Overview\r\n\r\nThe process of converting manual annotations (numbered/alphabetical indicators with connected descriptions) to Figma's native annotations:\r\n\r\n1. Get selected frame/component information\r\n2. Scan and collect all annotation text nodes\r\n3. Scan target UI elements (components, instances, frames)\r\n4. Match annotations to appropriate UI elements\r\n5. Apply native Figma annotations\r\n\r\n## Step 1: Get Selection and Initial Setup\r\n\r\nFirst, get the selected frame or component that contains annotations:\r\n\r\n\\`\\`\\`typescript\r\n// Get the selected frame/component\r\nconst selection = await get_selection();\r\nconst selectedNodeId = selection[0].id\r\n\r\n// Get available annotation categories for later use\r\nconst annotationData = await get_annotations({\r\n  nodeId: selectedNodeId,\r\n  includeCategories: true\r\n});\r\nconst categories = annotationData.categories;\r\n\\`\\`\\`\r\n\r\n## Step 2: Scan Annotation Text Nodes\r\n\r\nScan all text nodes to identify annotations and their descriptions:\r\n\r\n\\`\\`\\`typescript\r\n// Get all text nodes in the selection\r\nconst textNodes = await scan_text_nodes({\r\n  nodeId: selectedNodeId\r\n});\r\n\r\n// Filter and group annotation markers and descriptions\r\n\r\n// Markers typically have these characteristics:\r\n// - Short text content (usually single digit/letter)\r\n// - Specific font styles (often bold)\r\n// - Located in a container with \"Marker\" or \"Dot\" in the name\r\n// - Have a clear naming pattern (e.g., \"1\", \"2\", \"3\" or \"A\", \"B\", \"C\")\r\n\r\n\r\n// Identify description nodes\r\n// Usually longer text nodes near markers or with matching numbers in path\r\n  \r\n\\`\\`\\`\r\n\r\n## Step 3: Scan Target UI Elements\r\n\r\nGet all potential target elements that annotations might refer to:\r\n\r\n\\`\\`\\`typescript\r\n// Scan for all UI elements that could be annotation targets\r\nconst targetNodes = await scan_nodes_by_types({\r\n  nodeId: selectedNodeId,\r\n  types: [\r\n    \"COMPONENT\",\r\n    \"INSTANCE\",\r\n    \"FRAME\"\r\n  ]\r\n});\r\n\\`\\`\\`\r\n\r\n## Step 4: Match Annotations to Targets\r\n\r\nMatch each annotation to its target UI element using these strategies in order of priority:\r\n\r\n1. **Path-Based Matching**:\r\n   - Look at the marker's parent container name in the Figma layer hierarchy\r\n   - Remove any \"Marker:\" or \"Annotation:\" prefixes from the parent name\r\n   - Find UI elements that share the same parent name or have it in their path\r\n   - This works well when markers are grouped with their target elements\r\n\r\n2. **Name-Based Matching**:\r\n   - Extract key terms from the annotation description\r\n   - Look for UI elements whose names contain these key terms\r\n   - Consider both exact matches and semantic similarities\r\n   - Particularly effective for form fields, buttons, and labeled components\r\n\r\n3. **Proximity-Based Matching** (fallback):\r\n   - Calculate the center point of the marker\r\n   - Find the closest UI element by measuring distances to element centers\r\n   - Consider the marker's position relative to nearby elements\r\n   - Use this method when other matching strategies fail\r\n\r\nAdditional Matching Considerations:\r\n- Give higher priority to matches found through path-based matching\r\n- Consider the type of UI element when evaluating matches\r\n- Take into account the annotation's context and content\r\n- Use a combination of strategies for more accurate matching\r\n\r\n## Step 5: Apply Native Annotations\r\n\r\nConvert matched annotations to Figma's native annotations using batch processing:\r\n\r\n\\`\\`\\`typescript\r\n// Prepare annotations array for batch processing\r\nconst annotationsToApply = Object.values(annotations).map(({ marker, description }) => {\r\n  // Find target using multiple strategies\r\n  const target = \r\n    findTargetByPath(marker, targetNodes) ||\r\n    findTargetByName(description, targetNodes) ||\r\n    findTargetByProximity(marker, targetNodes);\r\n  \r\n  if (target) {\r\n    // Determine appropriate category based on content\r\n    const category = determineCategory(description.characters, categories);\r\n\r\n    // Determine appropriate additional annotationProperty based on content\r\n    const annotationProperty = determineProperties(description.characters, target.type);\r\n    \r\n    return {\r\n      nodeId: target.id,\r\n      labelMarkdown: description.characters,\r\n      categoryId: category.id,\r\n      properties: annotationProperty\r\n    };\r\n  }\r\n  return null;\r\n}).filter(Boolean); // Remove null entries\r\n\r\n// Apply annotations in batches using set_multiple_annotations\r\nif (annotationsToApply.length > 0) {\r\n  await set_multiple_annotations({\r\n    nodeId: selectedNodeId,\r\n    annotations: annotationsToApply\r\n  });\r\n}\r\n\\`\\`\\`\r\n\r\n\r\nThis strategy focuses on practical implementation based on real-world usage patterns, emphasizing the importance of handling various UI elements as annotation targets, not just text nodes.`\r\n          },\r\n        },\r\n      ],\r\n      description: \"Strategy for converting manual annotations to Figma's native annotations\",\r\n    };\r\n  }\r\n);\r\n\r\n// Instance Slot Filling Strategy Prompt\r\nserver.prompt(\r\n  \"swap_overrides_instances\",\r\n  \"Guide to swap instance overrides between instances\",\r\n  (extra) => {\r\n    return {\r\n      messages: [\r\n        {\r\n          role: \"assistant\",\r\n          content: {\r\n            type: \"text\",\r\n            text: `# Swap Component Instance and Override Strategy\r\n\r\n## Overview\r\nThis strategy enables transferring content and property overrides from a source instance to one or more target instances in Figma, maintaining design consistency while reducing manual work.\r\n\r\n## Step-by-Step Process\r\n\r\n### 1. Selection Analysis\r\n- Use \\`get_selection()\\` to identify the parent component or selected instances\r\n- For parent components, scan for instances with \\`scan_nodes_by_types({ nodeId: \"parent-id\", types: [\"INSTANCE\"] })\\`\r\n- Identify custom slots by name patterns (e.g. \"Custom Slot*\" or \"Instance Slot\") or by examining text content\r\n- Determine which is the source instance (with content to copy) and which are targets (where to apply content)\r\n\r\n### 2. Extract Source Overrides\r\n- Use \\`get_instance_overrides()\\` to extract customizations from the source instance\r\n- This captures text content, property values, and style overrides\r\n- Command syntax: \\`get_instance_overrides({ nodeId: \"source-instance-id\" })\\`\r\n- Look for successful response like \"Got component information from [instance name]\"\r\n\r\n### 3. Apply Overrides to Targets\r\n- Apply captured overrides using \\`set_instance_overrides()\\`\r\n- Command syntax:\r\n  \\`\\`\\`\r\n  set_instance_overrides({\r\n    sourceInstanceId: \"source-instance-id\", \r\n    targetNodeIds: [\"target-id-1\", \"target-id-2\", ...]\r\n  })\r\n  \\`\\`\\`\r\n\r\n### 4. Verification\r\n- Verify results with \\`get_node_info()\\` or \\`read_my_design()\\`\r\n- Confirm text content and style overrides have transferred successfully\r\n\r\n## Key Tips\r\n- Always join the appropriate channel first with \\`join_channel()\\`\r\n- When working with multiple targets, check the full selection with \\`get_selection()\\`\r\n- Preserve component relationships by using instance overrides rather than direct text manipulation`,\r\n          },\r\n        },\r\n      ],\r\n      description: \"Strategy for transferring overrides between component instances in Figma\",\r\n    };\r\n  }\r\n);\r\n\r\n// Set Layout Mode Tool\r\nserver.tool(\r\n  \"set_layout_mode\",\r\n  \"Set the layout mode and wrap behavior of a frame in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the frame to modify\"),\r\n    layoutMode: z.enum([\"NONE\", \"HORIZONTAL\", \"VERTICAL\"]).describe(\"Layout mode for the frame\"),\r\n    layoutWrap: z.enum([\"NO_WRAP\", \"WRAP\"]).optional().describe(\"Whether the auto-layout frame wraps its children\")\r\n  },\r\n  async ({ nodeId, layoutMode, layoutWrap }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_layout_mode\", {\r\n        nodeId,\r\n        layoutMode,\r\n        layoutWrap: layoutWrap || \"NO_WRAP\"\r\n      });\r\n      const typedResult = result as { name: string };\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set layout mode of frame \"${typedResult.name}\" to ${layoutMode}${layoutWrap ? ` with ${layoutWrap}` : ''}`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting layout mode: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Padding Tool\r\nserver.tool(\r\n  \"set_padding\",\r\n  \"Set padding values for an auto-layout frame in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the frame to modify\"),\r\n    paddingTop: z.number().optional().describe(\"Top padding value\"),\r\n    paddingRight: z.number().optional().describe(\"Right padding value\"),\r\n    paddingBottom: z.number().optional().describe(\"Bottom padding value\"),\r\n    paddingLeft: z.number().optional().describe(\"Left padding value\"),\r\n  },\r\n  async ({ nodeId, paddingTop, paddingRight, paddingBottom, paddingLeft }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_padding\", {\r\n        nodeId,\r\n        paddingTop,\r\n        paddingRight,\r\n        paddingBottom,\r\n        paddingLeft,\r\n      });\r\n      const typedResult = result as { name: string };\r\n\r\n      // Create a message about which padding values were set\r\n      const paddingMessages = [];\r\n      if (paddingTop !== undefined) paddingMessages.push(`top: ${paddingTop}`);\r\n      if (paddingRight !== undefined) paddingMessages.push(`right: ${paddingRight}`);\r\n      if (paddingBottom !== undefined) paddingMessages.push(`bottom: ${paddingBottom}`);\r\n      if (paddingLeft !== undefined) paddingMessages.push(`left: ${paddingLeft}`);\r\n\r\n      const paddingText = paddingMessages.length > 0\r\n        ? `padding (${paddingMessages.join(', ')})`\r\n        : \"padding\";\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set ${paddingText} for frame \"${typedResult.name}\"`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting padding: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Axis Align Tool\r\nserver.tool(\r\n  \"set_axis_align\",\r\n  \"Set primary and counter axis alignment for an auto-layout frame in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the frame to modify\"),\r\n    primaryAxisAlignItems: z\r\n      .enum([\"MIN\", \"MAX\", \"CENTER\", \"SPACE_BETWEEN\"])\r\n      .optional()\r\n      .describe(\"Primary axis alignment (MIN/MAX = left/right in horizontal, top/bottom in vertical). Note: When set to SPACE_BETWEEN, itemSpacing will be ignored as children will be evenly spaced.\"),\r\n    counterAxisAlignItems: z\r\n      .enum([\"MIN\", \"MAX\", \"CENTER\", \"BASELINE\"])\r\n      .optional()\r\n      .describe(\"Counter axis alignment (MIN/MAX = top/bottom in horizontal, left/right in vertical)\")\r\n  },\r\n  async ({ nodeId, primaryAxisAlignItems, counterAxisAlignItems }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_axis_align\", {\r\n        nodeId,\r\n        primaryAxisAlignItems,\r\n        counterAxisAlignItems\r\n      });\r\n      const typedResult = result as { name: string };\r\n\r\n      // Create a message about which alignments were set\r\n      const alignMessages = [];\r\n      if (primaryAxisAlignItems !== undefined) alignMessages.push(`primary: ${primaryAxisAlignItems}`);\r\n      if (counterAxisAlignItems !== undefined) alignMessages.push(`counter: ${counterAxisAlignItems}`);\r\n\r\n      const alignText = alignMessages.length > 0\r\n        ? `axis alignment (${alignMessages.join(', ')})`\r\n        : \"axis alignment\";\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set ${alignText} for frame \"${typedResult.name}\"`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting axis alignment: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Layout Sizing Tool\r\nserver.tool(\r\n  \"set_layout_sizing\",\r\n  \"Set horizontal and vertical sizing modes for an auto-layout frame in Figma\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the frame to modify\"),\r\n    layoutSizingHorizontal: z\r\n      .enum([\"FIXED\", \"HUG\", \"FILL\"])\r\n      .optional()\r\n      .describe(\"Horizontal sizing mode (HUG for frames/text only, FILL for auto-layout children only)\"),\r\n    layoutSizingVertical: z\r\n      .enum([\"FIXED\", \"HUG\", \"FILL\"])\r\n      .optional()\r\n      .describe(\"Vertical sizing mode (HUG for frames/text only, FILL for auto-layout children only)\")\r\n  },\r\n  async ({ nodeId, layoutSizingHorizontal, layoutSizingVertical }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_layout_sizing\", {\r\n        nodeId,\r\n        layoutSizingHorizontal,\r\n        layoutSizingVertical\r\n      });\r\n      const typedResult = result as { name: string };\r\n\r\n      // Create a message about which sizing modes were set\r\n      const sizingMessages = [];\r\n      if (layoutSizingHorizontal !== undefined) sizingMessages.push(`horizontal: ${layoutSizingHorizontal}`);\r\n      if (layoutSizingVertical !== undefined) sizingMessages.push(`vertical: ${layoutSizingVertical}`);\r\n\r\n      const sizingText = sizingMessages.length > 0\r\n        ? `layout sizing (${sizingMessages.join(', ')})`\r\n        : \"layout sizing\";\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set ${sizingText} for frame \"${typedResult.name}\"`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting layout sizing: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Set Item Spacing Tool\r\nserver.tool(\r\n  \"set_item_spacing\",\r\n  \"Set distance between children in an auto-layout frame\",\r\n  {\r\n    nodeId: z.string().describe(\"The ID of the frame to modify\"),\r\n    itemSpacing: z.number().describe(\"Distance between children. Note: This value will be ignored if primaryAxisAlignItems is set to SPACE_BETWEEN.\")\r\n  },\r\n  async ({ nodeId, itemSpacing }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_item_spacing\", {\r\n        nodeId,\r\n        itemSpacing\r\n      });\r\n      const typedResult = result as { name: string };\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Set item spacing to ${itemSpacing} for frame \"${typedResult.name}\"`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting item spacing: ${error instanceof Error ? error.message : String(error)}`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// A tool to get Figma Prototyping Reactions from multiple nodes\r\nserver.tool(\r\n  \"get_reactions\",\r\n  \"Get Figma Prototyping Reactions from multiple nodes. CRITICAL: The output MUST be processed using the 'reaction_to_connector_strategy' prompt IMMEDIATELY to generate parameters for connector lines via the 'create_connections' tool.\",\r\n  {\r\n    nodeIds: z.array(z.string()).describe(\"Array of node IDs to get reactions from\"),\r\n  },\r\n  async ({ nodeIds }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"get_reactions\", { nodeIds });\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: JSON.stringify(result)\r\n          },\r\n          {\r\n            type: \"text\",\r\n            text: \"IMPORTANT: You MUST now use the reaction data above and follow the `reaction_to_connector_strategy` prompt to prepare the parameters for the `create_connections` tool call. This is a required next step.\"\r\n          }\r\n        ],\r\n        followUp: {\r\n          type: \"prompt\",\r\n          prompt: \"reaction_to_connector_strategy\",\r\n        },\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error getting reactions: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Create Connectors Tool\r\nserver.tool(\r\n  \"set_default_connector\",\r\n  \"Set a copied connector node as the default connector\",\r\n  {\r\n    connectorId: z.string().optional().describe(\"The ID of the connector node to set as default\")\r\n  },\r\n  async ({ connectorId }) => {\r\n    try {\r\n      const result = await sendCommandToFigma(\"set_default_connector\", {\r\n        connectorId\r\n      });\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Default connector set: ${JSON.stringify(result)}`\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error setting default connector: ${error instanceof Error ? error.message : String(error)}`\r\n          }\r\n        ]\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Connect Nodes Tool\r\nserver.tool(\r\n  \"create_connections\",\r\n  \"Create connections between nodes using the default connector style\",\r\n  {\r\n    connections: z.array(z.object({\r\n      startNodeId: z.string().describe(\"ID of the starting node\"),\r\n      endNodeId: z.string().describe(\"ID of the ending node\"),\r\n      text: z.string().optional().describe(\"Optional text to display on the connector\")\r\n    })).describe(\"Array of node connections to create\")\r\n  },\r\n  async ({ connections }) => {\r\n    try {\r\n      if (!connections || connections.length === 0) {\r\n        return {\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text: \"No connections provided\"\r\n            }\r\n          ]\r\n        };\r\n      }\r\n\r\n      const result = await sendCommandToFigma(\"create_connections\", {\r\n        connections\r\n      });\r\n\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Created ${connections.length} connections: ${JSON.stringify(result)}`\r\n          }\r\n        ]\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error creating connections: ${error instanceof Error ? error.message : String(error)}`\r\n          }\r\n        ]\r\n      };\r\n    }\r\n  }\r\n);\r\n\r\n// Strategy for converting Figma prototype reactions to connector lines\r\nserver.prompt(\r\n  \"reaction_to_connector_strategy\",\r\n  \"Strategy for converting Figma prototype reactions to connector lines using the output of 'get_reactions'\",\r\n  (extra) => {\r\n    return {\r\n      messages: [\r\n        {\r\n          role: \"assistant\",\r\n          content: {\r\n            type: \"text\",\r\n            text: `# Strategy: Convert Figma Prototype Reactions to Connector Lines\r\n\r\n## Goal\r\nProcess the JSON output from the \\`get_reactions\\` tool to generate an array of connection objects suitable for the \\`create_connections\\` tool. This visually represents prototype flows as connector lines on the Figma canvas.\r\n\r\n## Input Data\r\nYou will receive JSON data from the \\`get_reactions\\` tool. This data contains an array of nodes, each with potential reactions. A typical reaction object looks like this:\r\n\\`\\`\\`json\r\n{\r\n  \"trigger\": { \"type\": \"ON_CLICK\" },\r\n  \"action\": {\r\n    \"type\": \"NAVIGATE\",\r\n    \"destinationId\": \"destination-node-id\",\r\n    \"navigationTransition\": { ... },\r\n    \"preserveScrollPosition\": false\r\n  }\r\n}\r\n\\`\\`\\`\r\n\r\n## Step-by-Step Process\r\n\r\n### 1. Preparation & Context Gathering\r\n   - **Action:** Call \\`read_my_design\\` on the relevant node(s) to get context about the nodes involved (names, types, etc.). This helps in generating meaningful connector labels later.\r\n   - **Action:** Call \\`set_default_connector\\` **without** the \\`connectorId\\` parameter.\r\n   - **Check Result:** Analyze the response from \\`set_default_connector\\`.\r\n     - If it confirms a default connector is already set (e.g., \"Default connector is already set\"), proceed to Step 2.\r\n     - If it indicates no default connector is set (e.g., \"No default connector set...\"), you **cannot** proceed with \\`create_connections\\` yet. Inform the user they need to manually copy a connector from FigJam, paste it onto the current page, select it, and then you can run \\`set_default_connector({ connectorId: \"SELECTED_NODE_ID\" })\\` before attempting \\`create_connections\\`. **Do not proceed to Step 2 until a default connector is confirmed.**\r\n\r\n### 2. Filter and Transform Reactions from \\`get_reactions\\` Output\r\n   - **Iterate:** Go through the JSON array provided by \\`get_reactions\\`. For each node in the array:\r\n     - Iterate through its \\`reactions\\` array.\r\n   - **Filter:** Keep only reactions where the \\`action\\` meets these criteria:\r\n     - Has a \\`type\\` that implies a connection (e.g., \\`NAVIGATE\\`, \\`OPEN_OVERLAY\\`, \\`SWAP_OVERLAY\\`). **Ignore** types like \\`CHANGE_TO\\`, \\`CLOSE_OVERLAY\\`, etc.\r\n     - Has a valid \\`destinationId\\` property.\r\n   - **Extract:** For each valid reaction, extract the following information:\r\n     - \\`sourceNodeId\\`: The ID of the node the reaction belongs to (from the outer loop).\r\n     - \\`destinationNodeId\\`: The value of \\`action.destinationId\\`.\r\n     - \\`actionType\\`: The value of \\`action.type\\`.\r\n     - \\`triggerType\\`: The value of \\`trigger.type\\`.\r\n\r\n### 3. Generate Connector Text Labels\r\n   - **For each extracted connection:** Create a concise, descriptive text label string.\r\n   - **Combine Information:** Use the \\`actionType\\`, \\`triggerType\\`, and potentially the names of the source/destination nodes (obtained from Step 1's \\`read_my_design\\` or by calling \\`get_node_info\\` if necessary) to generate the label.\r\n   - **Example Labels:**\r\n     - If \\`triggerType\\` is \"ON\\_CLICK\" and \\`actionType\\` is \"NAVIGATE\": \"On click, navigate to [Destination Node Name]\"\r\n     - If \\`triggerType\\` is \"ON\\_DRAG\" and \\`actionType\\` is \"OPEN\\_OVERLAY\": \"On drag, open [Destination Node Name] overlay\"\r\n   - **Keep it brief and informative.** Let this generated string be \\`generatedText\\`.\r\n\r\n### 4. Prepare the \\`connections\\` Array for \\`create_connections\\`\r\n   - **Structure:** Create a JSON array where each element is an object representing a connection.\r\n   - **Format:** Each object in the array must have the following structure:\r\n     \\`\\`\\`json\r\n     {\r\n       \"startNodeId\": \"sourceNodeId_from_step_2\",\r\n       \"endNodeId\": \"destinationNodeId_from_step_2\",\r\n       \"text\": \"generatedText_from_step_3\"\r\n     }\r\n     \\`\\`\\`\r\n   - **Result:** This final array is the value you will pass to the \\`connections\\` parameter when calling the \\`create_connections\\` tool.\r\n\r\n### 5. Execute Connection Creation\r\n   - **Action:** Call the \\`create_connections\\` tool, passing the array generated in Step 4 as the \\`connections\\` argument.\r\n   - **Verify:** Check the response from \\`create_connections\\` to confirm success or failure.\r\n\r\nThis detailed process ensures you correctly interpret the reaction data, prepare the necessary information, and use the appropriate tools to create the connector lines.`\r\n          },\r\n        },\r\n      ],\r\n      description: \"Strategy for converting Figma prototype reactions to connector lines using the output of 'get_reactions'\",\r\n    };\r\n  }\r\n);\r\n\r\n\r\n// Define command types and parameters\r\ntype FigmaCommand =\r\n  | \"get_document_info\"\r\n  | \"get_selection\"\r\n  | \"get_node_info\"\r\n  | \"get_nodes_info\"\r\n  | \"read_my_design\"\r\n  | \"create_rectangle\"\r\n  | \"create_frame\"\r\n  | \"create_text\"\r\n  | \"set_fill_color\"\r\n  | \"set_stroke_color\"\r\n  | \"move_node\"\r\n  | \"resize_node\"\r\n  | \"delete_node\"\r\n  | \"delete_multiple_nodes\"\r\n  | \"get_styles\"\r\n  | \"get_local_components\"\r\n  | \"create_component_instance\"\r\n  | \"get_instance_overrides\"\r\n  | \"set_instance_overrides\"\r\n  | \"export_node_as_image\"\r\n  | \"join\"\r\n  | \"set_corner_radius\"\r\n  | \"clone_node\"\r\n  | \"set_text_content\"\r\n  | \"scan_text_nodes\"\r\n  | \"set_multiple_text_contents\"\r\n  | \"get_annotations\"\r\n  | \"set_annotation\"\r\n  | \"set_multiple_annotations\"\r\n  | \"scan_nodes_by_types\"\r\n  | \"set_layout_mode\"\r\n  | \"set_padding\"\r\n  | \"set_axis_align\"\r\n  | \"set_layout_sizing\"\r\n  | \"set_item_spacing\"\r\n  | \"get_reactions\"\r\n  | \"set_default_connector\"\r\n  | \"create_connections\";\r\n\r\ntype CommandParams = {\r\n  get_document_info: Record<string, never>;\r\n  get_selection: Record<string, never>;\r\n  get_node_info: { nodeId: string };\r\n  get_nodes_info: { nodeIds: string[] };\r\n  create_rectangle: {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    name?: string;\r\n    parentId?: string;\r\n  };\r\n  create_frame: {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    name?: string;\r\n    parentId?: string;\r\n    fillColor?: { r: number; g: number; b: number; a?: number };\r\n    strokeColor?: { r: number; g: number; b: number; a?: number };\r\n    strokeWeight?: number;\r\n  };\r\n  create_text: {\r\n    x: number;\r\n    y: number;\r\n    text: string;\r\n    fontSize?: number;\r\n    fontWeight?: number;\r\n    fontColor?: { r: number; g: number; b: number; a?: number };\r\n    name?: string;\r\n    parentId?: string;\r\n  };\r\n  set_fill_color: {\r\n    nodeId: string;\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n    a?: number;\r\n  };\r\n  set_stroke_color: {\r\n    nodeId: string;\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n    a?: number;\r\n    weight?: number;\r\n  };\r\n  move_node: {\r\n    nodeId: string;\r\n    x: number;\r\n    y: number;\r\n  };\r\n  resize_node: {\r\n    nodeId: string;\r\n    width: number;\r\n    height: number;\r\n  };\r\n  delete_node: {\r\n    nodeId: string;\r\n  };\r\n  delete_multiple_nodes: {\r\n    nodeIds: string[];\r\n  };\r\n  get_styles: Record<string, never>;\r\n  get_local_components: Record<string, never>;\r\n  get_team_components: Record<string, never>;\r\n  create_component_instance: {\r\n    componentKey: string;\r\n    x: number;\r\n    y: number;\r\n  };\r\n  get_instance_overrides: {\r\n    instanceNodeId: string | null;\r\n  };\r\n  set_instance_overrides: {\r\n    targetNodeIds: string[];\r\n    sourceInstanceId: string;\r\n  };\r\n  export_node_as_image: {\r\n    nodeId: string;\r\n    format?: \"PNG\" | \"JPG\" | \"SVG\" | \"PDF\";\r\n    scale?: number;\r\n  };\r\n  execute_code: {\r\n    code: string;\r\n  };\r\n  join: {\r\n    channel: string;\r\n  };\r\n  set_corner_radius: {\r\n    nodeId: string;\r\n    radius: number;\r\n    corners?: boolean[];\r\n  };\r\n  clone_node: {\r\n    nodeId: string;\r\n    x?: number;\r\n    y?: number;\r\n  };\r\n  set_text_content: {\r\n    nodeId: string;\r\n    text: string;\r\n  };\r\n  scan_text_nodes: {\r\n    nodeId: string;\r\n    useChunking: boolean;\r\n    chunkSize: number;\r\n  };\r\n  set_multiple_text_contents: {\r\n    nodeId: string;\r\n    text: Array<{ nodeId: string; text: string }>;\r\n  };\r\n  get_annotations: {\r\n    nodeId?: string;\r\n    includeCategories?: boolean;\r\n  };\r\n  set_annotation: {\r\n    nodeId: string;\r\n    annotationId?: string;\r\n    labelMarkdown: string;\r\n    categoryId?: string;\r\n    properties?: Array<{ type: string }>;\r\n  };\r\n  set_multiple_annotations: SetMultipleAnnotationsParams;\r\n  scan_nodes_by_types: {\r\n    nodeId: string;\r\n    types: Array<string>;\r\n  };\r\n  get_reactions: { nodeIds: string[] };\r\n  set_default_connector: {\r\n    connectorId?: string | undefined;\r\n  };\r\n  create_connections: {\r\n    connections: Array<{\r\n      startNodeId: string;\r\n      endNodeId: string;\r\n      text?: string;\r\n    }>;\r\n  };\r\n  \r\n};\r\n\r\n\r\n  // Helper function to process Figma node responses\r\nfunction processFigmaNodeResponse(result: unknown): any {\r\n  if (!result || typeof result !== \"object\") {\r\n    return result;\r\n  }\r\n\r\n  // Check if this looks like a node response\r\n  const resultObj = result as Record<string, unknown>;\r\n  if (\"id\" in resultObj && typeof resultObj.id === \"string\") {\r\n    // It appears to be a node response, log the details\r\n    console.info(\r\n      `Processed Figma node: ${resultObj.name || \"Unknown\"} (ID: ${resultObj.id\r\n      })`\r\n    );\r\n\r\n    if (\"x\" in resultObj && \"y\" in resultObj) {\r\n      console.debug(`Node position: (${resultObj.x}, ${resultObj.y})`);\r\n    }\r\n\r\n    if (\"width\" in resultObj && \"height\" in resultObj) {\r\n      console.debug(`Node dimensions: ${resultObj.width}${resultObj.height}`);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Update the connectToFigma function\r\nfunction connectToFigma(port: number = 3055) {\r\n  // If already connected, do nothing\r\n  if (ws && ws.readyState === WebSocket.OPEN) {\r\n    logger.info('Already connected to Figma');\r\n    return;\r\n  }\r\n\r\n  const wsUrl = serverUrl === 'localhost' ? `${WS_URL}:${port}` : WS_URL;\r\n  logger.info(`Connecting to Figma socket server at ${wsUrl}...`);\r\n  ws = new WebSocket(wsUrl);\r\n\r\n  ws.on('open', () => {\r\n    logger.info('Connected to Figma socket server');\r\n    // Reset channel on new connection\r\n    currentChannel = null;\r\n  });\r\n\r\n  ws.on(\"message\", (data: any) => {\r\n    try {\r\n      // Define a more specific type with an index signature to allow any property access\r\n      interface ProgressMessage {\r\n        message: FigmaResponse | any;\r\n        type?: string;\r\n        id?: string;\r\n        [key: string]: any; // Allow any other properties\r\n      }\r\n\r\n      const json = JSON.parse(data) as ProgressMessage;\r\n\r\n      // Handle progress updates\r\n      if (json.type === 'progress_update') {\r\n        const progressData = json.message.data as CommandProgressUpdate;\r\n        const requestId = json.id || '';\r\n\r\n        if (requestId && pendingRequests.has(requestId)) {\r\n          const request = pendingRequests.get(requestId)!;\r\n\r\n          // Update last activity timestamp\r\n          request.lastActivity = Date.now();\r\n\r\n          // Reset the timeout to prevent timeouts during long-running operations\r\n          clearTimeout(request.timeout);\r\n\r\n          // Create a new timeout\r\n          request.timeout = setTimeout(() => {\r\n            if (pendingRequests.has(requestId)) {\r\n              logger.error(`Request ${requestId} timed out after extended period of inactivity`);\r\n              pendingRequests.delete(requestId);\r\n              request.reject(new Error('Request to Figma timed out'));\r\n            }\r\n          }, 60000); // 60 second timeout for inactivity\r\n\r\n          // Log progress\r\n          logger.info(`Progress update for ${progressData.commandType}: ${progressData.progress}% - ${progressData.message}`);\r\n\r\n          // For completed updates, we could resolve the request early if desired\r\n          if (progressData.status === 'completed' && progressData.progress === 100) {\r\n            // Optionally resolve early with partial data\r\n            // request.resolve(progressData.payload);\r\n            // pendingRequests.delete(requestId);\r\n\r\n            // Instead, just log the completion, wait for final result from Figma\r\n            logger.info(`Operation ${progressData.commandType} completed, waiting for final result`);\r\n          }\r\n        }\r\n        return;\r\n      }\r\n\r\n      // Handle regular responses\r\n      const myResponse = json.message;\r\n      logger.debug(`Received message: ${JSON.stringify(myResponse)}`);\r\n      logger.log('myResponse' + JSON.stringify(myResponse));\r\n\r\n      // Handle response to a request\r\n      if (\r\n        myResponse.id &&\r\n        pendingRequests.has(myResponse.id) &&\r\n        myResponse.result\r\n      ) {\r\n        const request = pendingRequests.get(myResponse.id)!;\r\n        clearTimeout(request.timeout);\r\n\r\n        if (myResponse.error) {\r\n          logger.error(`Error from Figma: ${myResponse.error}`);\r\n          request.reject(new Error(myResponse.error));\r\n        } else {\r\n          if (myResponse.result) {\r\n            request.resolve(myResponse.result);\r\n          }\r\n        }\r\n\r\n        pendingRequests.delete(myResponse.id);\r\n      } else {\r\n        // Handle broadcast messages or events\r\n        logger.info(`Received broadcast message: ${JSON.stringify(myResponse)}`);\r\n      }\r\n    } catch (error) {\r\n      logger.error(`Error parsing message: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  });\r\n\r\n  ws.on('error', (error) => {\r\n    logger.error(`Socket error: ${error}`);\r\n  });\r\n\r\n  ws.on('close', () => {\r\n    logger.info('Disconnected from Figma socket server');\r\n    ws = null;\r\n\r\n    // Reject all pending requests\r\n    for (const [id, request] of pendingRequests.entries()) {\r\n      clearTimeout(request.timeout);\r\n      request.reject(new Error(\"Connection closed\"));\r\n      pendingRequests.delete(id);\r\n    }\r\n\r\n    // Attempt to reconnect\r\n    logger.info('Attempting to reconnect in 2 seconds...');\r\n    setTimeout(() => connectToFigma(port), 2000);\r\n  });\r\n}\r\n\r\n// Function to join a channel\r\nasync function joinChannel(channelName: string): Promise<void> {\r\n  if (!ws || ws.readyState !== WebSocket.OPEN) {\r\n    throw new Error(\"Not connected to Figma\");\r\n  }\r\n\r\n  try {\r\n    await sendCommandToFigma(\"join\", { channel: channelName });\r\n    currentChannel = channelName;\r\n    logger.info(`Joined channel: ${channelName}`);\r\n  } catch (error) {\r\n    logger.error(`Failed to join channel: ${error instanceof Error ? error.message : String(error)}`);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Function to send commands to Figma\r\nfunction sendCommandToFigma(\r\n  command: FigmaCommand,\r\n  params: unknown = {},\r\n  timeoutMs: number = 30000\r\n): Promise<unknown> {\r\n  return new Promise((resolve, reject) => {\r\n    // If not connected, try to connect first\r\n    if (!ws || ws.readyState !== WebSocket.OPEN) {\r\n      connectToFigma();\r\n      reject(new Error(\"Not connected to Figma. Attempting to connect...\"));\r\n      return;\r\n    }\r\n\r\n    // Check if we need a channel for this command\r\n    const requiresChannel = command !== \"join\";\r\n    if (requiresChannel && !currentChannel) {\r\n      reject(new Error(\"Must join a channel before sending commands\"));\r\n      return;\r\n    }\r\n\r\n    const id = uuidv4();\r\n    const request = {\r\n      id,\r\n      type: command === \"join\" ? \"join\" : \"message\",\r\n      ...(command === \"join\"\r\n        ? { channel: (params as any).channel }\r\n        : { channel: currentChannel }),\r\n      message: {\r\n        id,\r\n        command,\r\n        params: {\r\n          ...(params as any),\r\n          commandId: id, // Include the command ID in params\r\n        },\r\n      },\r\n    };\r\n\r\n    // Set timeout for request\r\n    const timeout = setTimeout(() => {\r\n      if (pendingRequests.has(id)) {\r\n        pendingRequests.delete(id);\r\n        logger.error(`Request ${id} to Figma timed out after ${timeoutMs / 1000} seconds`);\r\n        reject(new Error('Request to Figma timed out'));\r\n      }\r\n    }, timeoutMs);\r\n\r\n    // Store the promise callbacks to resolve/reject later\r\n    pendingRequests.set(id, {\r\n      resolve,\r\n      reject,\r\n      timeout,\r\n      lastActivity: Date.now()\r\n    });\r\n\r\n    // Send the request\r\n    logger.info(`Sending command to Figma: ${command}`);\r\n    logger.debug(`Request details: ${JSON.stringify(request)}`);\r\n    ws.send(JSON.stringify(request));\r\n  });\r\n}\r\n\r\n// Update the join_channel tool\r\nserver.tool(\r\n  \"join_channel\",\r\n  \"Join a specific channel to communicate with Figma\",\r\n  {\r\n    channel: z.string().describe(\"The name of the channel to join\").default(\"\"),\r\n  },\r\n  async ({ channel }) => {\r\n    try {\r\n      if (!channel) {\r\n        // If no channel provided, ask the user for input\r\n        return {\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text: \"Please provide a channel name to join:\",\r\n            },\r\n          ],\r\n          followUp: {\r\n            tool: \"join_channel\",\r\n            description: \"Join the specified channel\",\r\n          },\r\n        };\r\n      }\r\n\r\n      await joinChannel(channel);\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Successfully joined channel: ${channel}`,\r\n          },\r\n        ],\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        content: [\r\n          {\r\n            type: \"text\",\r\n            text: `Error joining channel: ${error instanceof Error ? error.message : String(error)\r\n              }`,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n);\r\n       \r\n// Start the server\r\nasync function main() {\r\n  try {\r\n    // Try to connect to Figma socket server\r\n    connectToFigma();\r\n  } catch (error) {\r\n    logger.warn(`Could not connect to Figma initially: ${error instanceof Error ? error.message : String(error)}`);\r\n    logger.warn('Will try to connect when the first command is sent');\r\n  }\r\n\r\n  // Start the MCP server with stdio transport\r\n  const transport = new StdioServerTransport();\r\n  await server.connect(transport);\r\n  logger.info('FigmaMCP server running on stdio');\r\n}\r\n\r\n// Run the server\r\nmain().catch(error => {\r\n  logger.error(`Error starting FigmaMCP server: ${error instanceof Error ? error.message : String(error)}`);\r\n  process.exit(1);\r\n});\r\n\r\n\r\n\r\n"],"mappings":"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","names":[]}